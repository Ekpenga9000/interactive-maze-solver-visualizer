#!/usr/bin/env python3
"""
Tests for Enhanced Maze Features
Tests terrain costs, weighted pathfinding, and randomized positioning
"""

import pytest
import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from maze_generator import MazeGenerator as NewMazeGenerator
from maze_solver import MazeSolver as NewMazeSolver, Algorithm
from graph import ExplicitGraph, TerrainType
from typing import Dict, List, Tuple

class TestWeightedPathfinding:
    """Test weighted pathfinding capabilities"""
    
    def test_dijkstra_vs_bfs_with_terrain(self):
        """Test that Dijkstra finds lower-cost paths than BFS"""
        # Create a simple graph where Dijkstra should outperform BFS
        graph = ExplicitGraph(5, 3)
        
        # Create a scenario where shortest path != lowest cost path
        # Layout:
        # PATH - MUD  - MUD  - MUD  - PATH  (top row, high cost)
        # PATH - PATH - PATH - PATH - PATH  (middle row, low cost but longer)
        # PATH - WALL - WALL - WALL - PATH  (bottom row, blocked)
        
        positions_and_terrain = [
            ((0, 0), TerrainType.PATH), ((1, 0), TerrainType.MUD),
            ((2, 0), TerrainType.MUD), ((3, 0), TerrainType.MUD), ((4, 0), TerrainType.PATH),
            ((0, 1), TerrainType.PATH), ((1, 1), TerrainType.PATH),
            ((2, 1), TerrainType.PATH), ((3, 1), TerrainType.PATH), ((4, 1), TerrainType.PATH),
            ((0, 2), TerrainType.PATH), ((1, 2), TerrainType.WALL),
            ((2, 2), TerrainType.WALL), ((3, 2), TerrainType.WALL), ((4, 2), TerrainType.PATH)
        ]
        
        for pos, terrain in positions_and_terrain:
            graph.add_node(pos, terrain)
        
        # Add horizontal edges
        for y in range(3):\n            for x in range(4):\n                if graph.is_passable((x, y)) and graph.is_passable((x+1, y)):\n                    graph.add_edge((x, y), (x+1, y))\n        \n        # Add vertical edges\n        for y in range(2):\n            for x in range(5):\n                if graph.is_passable((x, y)) and graph.is_passable((x, y+1)):\n                    graph.add_edge((x, y), (x, y+1))\n        \n        solver = NewMazeSolver(graph)\n        start = (0, 0)\n        end = (4, 0)\n        \n        # Solve with both algorithms\n        bfs_path, bfs_visited = solver.solve(start, end, Algorithm.BFS)\n        dijkstra_path, dijkstra_visited = solver.solve(start, end, Algorithm.DIJKSTRA)\n        \n        # Calculate path costs\n        def calculate_path_cost(path):\n            cost = 0\n            for i in range(len(path) - 1):\n                cost += graph.get_edge_weight(path[i], path[i+1])\n            return cost\n        \n        bfs_cost = calculate_path_cost(bfs_path)\n        dijkstra_cost = calculate_path_cost(dijkstra_path)\n        \n        # Dijkstra should find a lower-cost path\n        assert dijkstra_cost <= bfs_cost\n        \n        # Both should reach the destination\n        assert bfs_path[0] == start and bfs_path[-1] == end\n        assert dijkstra_path[0] == start and dijkstra_path[-1] == end\n    \n    def test_terrain_cost_calculation(self):\n        \"\"\"Test that terrain costs are calculated correctly\"\"\"\n        graph = ExplicitGraph(3, 1)\n        \n        # Create path: PATH -> MUD -> WATER\n        graph.add_node((0, 0), TerrainType.PATH)\n        graph.add_node((1, 0), TerrainType.MUD)\n        graph.add_node((2, 0), TerrainType.WATER)\n        \n        graph.add_edge((0, 0), (1, 0))\n        graph.add_edge((1, 0), (2, 0))\n        \n        # Edge weights should be destination terrain cost\n        assert graph.get_edge_weight((0, 0), (1, 0)) == TerrainType.MUD.value  # 3\n        assert graph.get_edge_weight((1, 0), (2, 0)) == TerrainType.WATER.value  # 5\n    \n    def test_all_terrain_types_in_pathfinding(self):\n        \"\"\"Test pathfinding works with all terrain types\"\"\"\n        generator = NewMazeGenerator(7, 7)\n        \n        # Generate with all terrain types\n        terrain_probs = {\n            TerrainType.PATH: 0.3,\n            TerrainType.MUD: 0.2,\n            TerrainType.WATER: 0.2,\n            TerrainType.SAND: 0.2,\n            TerrainType.ICE: 0.1\n        }\n        \n        graph, start, end = generator.generate_with_positions(\n            terrain_probabilities=terrain_probs,\n            randomize_end=True\n        )\n        \n        solver = NewMazeSolver(graph)\n        \n        # Test all algorithms can handle mixed terrain\n        for algorithm in [Algorithm.DFS, Algorithm.BFS, Algorithm.DIJKSTRA]:\n            path, visited = solver.solve(start, end, algorithm)\n            assert len(path) >= 2\n            assert path[0] == start\n            assert path[-1] == end\n\nclass TestRandomizedPositioning:\n    \"\"\"Test randomized start/end positioning\"\"\"\n    \n    def test_randomized_end_variation(self):\n        \"\"\"Test that randomized end positions actually vary\"\"\"\n        generator = NewMazeGenerator(15, 15)\n        \n        end_positions = set()\n        for _ in range(10):\n            graph, start, end = generator.generate_with_positions(randomize_end=True)\n            end_positions.add(end)\n        \n        # Should have some variation (at least 2 different positions)\n        assert len(end_positions) >= 2\n    \n    def test_randomized_positions_are_valid(self):\n        \"\"\"Test that randomized positions are always valid\"\"\"\n        generator = NewMazeGenerator(11, 11)\n        \n        for _ in range(20):\n            graph, start, end = generator.generate_with_positions(\n                randomize_start=True,\n                randomize_end=True\n            )\n            \n            # Both positions should be passable\n            assert graph.is_passable(start)\n            assert graph.is_passable(end)\n            \n            # Should be different\n            assert start != end\n            \n            # Should be within bounds\n            assert 0 <= start[0] < graph.width\n            assert 0 <= start[1] < graph.height\n            assert 0 <= end[0] < graph.width\n            assert 0 <= end[1] < graph.height\n    \n    def test_strategic_positioning(self):\n        \"\"\"Test strategic positioning features\"\"\"\n        generator = NewMazeGenerator(21, 21)\n        graph, start, end = generator.generate_with_positions(randomize_end=True)\n        \n        # Get strategic positions\n        strategic_positions = generator.get_strategic_positions()\n        \n        assert len(strategic_positions) > 0\n        \n        # All strategic positions should be passable\n        for pos in strategic_positions:\n            assert graph.is_passable(pos)\n        \n        # When using randomized end, it should be one of the strategic positions\n        # (or at least a valid passable position)\n        assert graph.is_passable(end)\n\nclass TestTerrainDistribution:\n    \"\"\"Test terrain distribution and analysis\"\"\"\n    \n    def test_custom_terrain_probabilities(self):\n        \"\"\"Test that custom terrain probabilities are respected\"\"\"\n        generator = NewMazeGenerator(15, 15)\n        \n        # Force all passable terrain to be MUD\n        terrain_probs = {TerrainType.MUD: 1.0}\n        \n        graph, start, end = generator.generate_with_positions(\n            terrain_probabilities=terrain_probs\n        )\n        \n        # Check that most/all passable positions are MUD\n        mud_count = 0\n        total_passable = 0\n        \n        for pos in graph.get_all_passable_positions():\n            total_passable += 1\n            if graph.get_terrain_type(pos) == TerrainType.MUD:\n                mud_count += 1\n        \n        # Should be mostly MUD (allowing for some variation due to randomness)\n        assert mud_count / total_passable >= 0.8\n    \n    def test_terrain_info_extraction(self):\n        \"\"\"Test extracting terrain information\"\"\"\n        graph = ExplicitGraph(3, 3)\n        test_terrains = [\n            ((0, 0), TerrainType.PATH),\n            ((1, 0), TerrainType.MUD),\n            ((2, 0), TerrainType.WATER),\n            ((0, 1), TerrainType.SAND),\n            ((1, 1), TerrainType.ICE),\n            ((2, 1), TerrainType.WALL)\n        ]\n        \n        for pos, terrain in test_terrains:\n            graph.add_node(pos, terrain)\n        \n        solver = NewMazeSolver(graph)\n        \n        for pos, expected_terrain in test_terrains:\n            terrain_info = solver.get_terrain_info(pos)\n            \n            assert 'terrain' in terrain_info\n            assert 'cost' in terrain_info\n            assert terrain_info['terrain'] == expected_terrain\n            assert terrain_info['cost'] == expected_terrain.value\n\nclass TestGraphConversion:\n    \"\"\"Test graph conversion functionality\"\"\"\n    \n    def test_to_visual_grid(self):\n        \"\"\"Test converting graph to visual grid\"\"\"\n        graph = ExplicitGraph(3, 2)\n        graph.add_node((0, 0), TerrainType.PATH)\n        graph.add_node((1, 0), TerrainType.MUD)\n        graph.add_node((2, 0), TerrainType.WALL)\n        graph.add_node((0, 1), TerrainType.WATER)\n        graph.add_node((1, 1), TerrainType.SAND)\n        graph.add_node((2, 1), TerrainType.ICE)\n        \n        visual_grid = graph.to_visual_grid()\n        \n        # Check terrain mapping\n        assert visual_grid[0][0] == 0  # PATH\n        assert visual_grid[0][1] == 2  # MUD\n        assert visual_grid[0][2] == 1  # WALL\n        assert visual_grid[1][0] == 3  # WATER\n        assert visual_grid[1][1] == 4  # SAND\n        assert visual_grid[1][2] == 5  # ICE\n    \n    def test_to_simple_grid(self):\n        \"\"\"Test converting graph to simple binary grid\"\"\"\n        graph = ExplicitGraph(3, 2)\n        graph.add_node((0, 0), TerrainType.PATH)\n        graph.add_node((1, 0), TerrainType.MUD)\n        graph.add_node((2, 0), TerrainType.WALL)\n        graph.add_node((0, 1), TerrainType.WATER)\n        graph.add_node((1, 1), TerrainType.SAND)\n        graph.add_node((2, 1), TerrainType.ICE)\n        \n        simple_grid = graph.to_simple_grid()\n        \n        # All passable terrain should be 0, walls should be 1\n        assert simple_grid[0][0] == 0  # PATH (passable)\n        assert simple_grid[0][1] == 0  # MUD (passable)\n        assert simple_grid[0][2] == 1  # WALL (blocked)\n        assert simple_grid[1][0] == 0  # WATER (passable)\n        assert simple_grid[1][1] == 0  # SAND (passable)\n        assert simple_grid[1][2] == 0  # ICE (passable)\n\nclass TestAnimatedSolving:\n    \"\"\"Test animated solving with enhanced features\"\"\"\n    \n    def test_animated_solve_with_terrain(self):\n        \"\"\"Test that animated solving works with terrain costs\"\"\"\n        generator = NewMazeGenerator(11, 11)\n        graph, start, end = generator.generate_with_positions()\n        \n        solver = NewMazeSolver(graph)\n        \n        # Test animated Dijkstra (which uses terrain costs)\n        animation_states = list(solver.solve_animated(start, end, Algorithm.DIJKSTRA))\n        \n        assert len(animation_states) > 0\n        \n        # First state should be exploring\n        assert animation_states[0]['action'] == 'exploring'\n        assert animation_states[0]['current'] == start\n        \n        # Last state should be found\n        assert animation_states[-1]['action'] == 'found'\n        assert 'path' in animation_states[-1]\n        assert animation_states[-1]['path'][0] == start\n        assert animation_states[-1]['path'][-1] == end\n        \n        # Should have distances for Dijkstra\n        found_distances = False\n        for state in animation_states:\n            if 'distances' in state and len(state['distances']) > 0:\n                found_distances = True\n                break\n        \n        assert found_distances, \"Dijkstra animation should include distance information\"\n\nclass TestEdgeCases:\n    \"\"\"Test edge cases and error conditions\"\"\"\n    \n    def test_unsolvable_maze(self):\n        \"\"\"Test behavior with unsolvable maze\"\"\"\n        # Create a maze where start and end are disconnected\n        graph = ExplicitGraph(5, 3)\n        \n        # Start area (left side)\n        graph.add_node((0, 1), TerrainType.PATH)\n        graph.add_node((1, 1), TerrainType.PATH)\n        \n        # Wall barrier\n        graph.add_node((2, 0), TerrainType.WALL)\n        graph.add_node((2, 1), TerrainType.WALL)\n        graph.add_node((2, 2), TerrainType.WALL)\n        \n        # End area (right side)\n        graph.add_node((3, 1), TerrainType.PATH)\n        graph.add_node((4, 1), TerrainType.PATH)\n        \n        # Add edges within each area\n        graph.add_edge((0, 1), (1, 1))\n        graph.add_edge((3, 1), (4, 1))\n        \n        solver = NewMazeSolver(graph)\n        start = (0, 1)\n        end = (4, 1)\n        \n        # Should return empty path for unsolvable maze\n        path, visited = solver.solve(start, end, Algorithm.BFS)\n        \n        assert len(path) == 0\n        assert start in visited  # Should have visited start\n        assert end not in visited  # Should not reach end\n    \n    def test_start_equals_end(self):\n        \"\"\"Test behavior when start equals end\"\"\"\n        generator = NewMazeGenerator(11, 11)\n        graph, start, _ = generator.generate_with_positions()\n        \n        solver = NewMazeSolver(graph)\n        \n        # Solve where start == end\n        path, visited = solver.solve(start, start, Algorithm.BFS)\n        \n        assert len(path) == 1\n        assert path[0] == start\n        assert start in visited\n\nif __name__ == \"__main__\":\n    pytest.main([__file__])